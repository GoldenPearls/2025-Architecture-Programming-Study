# 1. 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고 올림은 두 비트를 AND 한 연산과 같다.

## 1) why?

1. 두 비트의 합

```
0+0=0 → 합비트 결과: 0
0+1=1 → 합비트 결과: 1
1+0=1 → 합비트 결과: 1
1+1=10 → 합비트 결과: 10
```

2. XOR 연산 (Exclusive OR, 배타적 논리합)

- XOR 연산이란?
  : 두 개의 입력이 다를 때 1을 출력하고, 같으면 0을 출력하는 연산

```
0 0=0 → XOR 결과: 0
0 1=1 → XOR 결과: 1
1 0=1 → XOR 결과: 1
1 1=10 (즉, 합 비트는 0이고 올림이 발생) → XOR 결과: 0
```

- XOR 연산은 이진수 덧셈에서 "합(Sum)"과 동일한 역할
  : XOR은 두 비트가 다를 때 1을 출력하고 같을 때 0을 출력한다. 이는 이진 덧셈에서 자릿수 합의 역할을 정확히 수행한다.

3. 올림 (Carry)과 AND 연산
   올림(Carry)은 두 개의 비트가 모두 1일 때 발생한다.

```
Carry=𝐴⋅𝐵=𝐴∧𝐵
```

// 올림 연산의 경우

```
0 0=0
0 1=0
1 0=0
1 1=1
```

// AND 연산의 경우

```
0 0=0
0 1=0
1 0=0
1 1=1
```

- 올림은 AND 연산과 동일

4. 수학적인 일반화

(1) XOR은 두 비트가 다를 때 1을 반환하는 성질이 있어서, 이진 덧셈의 합(Sum Bit) 역할을 한다.
(2) AND는 두 비트가 모두 1일 때만 1을 반환하는 성질이 있어서, 이진 덧셈의 올림(Carry Bit) 역할을 한다.

## 이진수 덧셈 진리표

| A   | B   | A + B (2진수) | 합 (Sum) | 올림 (Carry) |
| --- | --- | ------------- | -------- | ------------ |
| 0   | 0   | 0             | 0        | 0            |
| 0   | 1   | 1             | 1        | 0            |
| 1   | 0   | 1             | 1        | 0            |
| 1   | 1   | 10            | 0        | 1            |

이 규칙은 **반가산기(Half Adder)**의 기본적인 원리이기도 하다.

c.f. 반가산기?
: 이진수 덧셈을 수행하는 가장 기본적인 논리 회로로, 이진수의 한자리수를 연산하고 자리올림수는 자리올림수 출력(carry)에 따라 출력한다. AND, OR, NOT의 세 가지 종류의 논리회로만으로 구성할 수 있다. 하지만 이전 자리에서 발생한 올림(Carry-In)을 처리할 수 없다는 특징이 있어서 "반(Half)" 가산기라고 불린다.

![반가산기_회로](https://mblogthumb-phinf.pstatic.net/20110507_217/asd7979_1304732945444hrqAx_PNG/halfadder2.png?type=w420)

=> 이러한 성질을 기반으로, **반가산기(Half Adder)와 전가산기(Full Adder)**가 설계되고, 이것이 CPU에서 덧셈 연산을 수행하는 핵심 원리가 된다.

## 2) CPU에서 XOR을 수행하는 방식

: CPU는 기본 논리 게이트(AND, OR, NOT)를 조합해서 XOR을 구현

```
A⊕B=(A∨B)∧¬(A∧B)
```

- 하드웨어 최적화: XOR 게이트를 직접 사용하면 회로가 커질 수 있음 → 기본 게이트 조합이 더 효율적

  ** XOR은 기본 게이트보다 복잡한 논리 연산이라서, 하드웨어적으로 직접 만들면 추가적인 트랜지스터가 더 필요 **

  ** 든 논리 게이트는 **트랜지스터(Transistor)**로 구성됨. 트랜지스터 개수가 많아지면 회로가 커지고, 전력 소비가 증가하며, 속도도 저하 **

- 게이트 수 최소화: CPU는 AND, OR, NOT 게이트만으로 XOR을 구성하여 칩 크기를 줄이고 속도를 높임.
  (XOR을 직접 설계하면 추가적인 회로가 필요하므로 기존의 기본 게이트로 XOR을 구현하는 것이 경제적)

- 전가산기(Full Adder) 최적화: XOR이 포함된 전가산기 설계에서도 기본 논리 게이트로 XOR을 만들고 사용.

# 2. 왜 1의 보수 계산법에서는 추가적인 하드웨어가 들까?

## 1) 1의 보수(One’s Complement)란?

: 1의 보수는 음수를 표현하는 방법 중 하나로, **모든 비트를 반전(1 → 0, 0 → 1)**시켜 음수를 나타냄.

```
+5	0101
-5	1010 (반전)
+7	0111
-7	1000 (반전)
```

## 2) 1의 보수 덧셈에서 발생하는 캐리 보정 문제

: 1의 보수 방식에서는 캐리 비트가 발생하면 이를 다시 더해야 하는 "캐리 보정(Carry Correction)" 과정이 필요

c.f. 캐리 보정이란?
: 1의 보수(One's Complement) 연산에서 덧셈 결과가 올바르지 않을 때, 발생한 캐리를 다시 더해서 올바른 결과를 만드는 과정

e.g. (-5 + 3)

```
  1010   (-5, 1의 보수)
+ 0011   (+3)
------------
  1101   (-2의 1의 보수 표현)

```

e.g.3 (-3) + (-2)

```
  1100   (-3, 1의 보수)
+ 1101   (-2, 1의 보수)
------------
  10001   (5비트가 됨 → 최상위 캐리 발생)
+ 0001   (캐리 보정 추가)
------------
  0010   (-5, 1의 보수 표현)
```

=> 최상위 비트(MSB)에서 캐리가 발생한 경우, 발생한 캐리를 다시 결과에 더해야 한다.

e.g.2 (-5 + 5)

```
  1010   (-5, 1의 보수)
+ 0101   (+5)
------------
  1111   (올바른 결과는 0이어야 하나 결과가 -0)
+ 0001   (캐리 보정 추가)
------------
  0000   (최종적으로 올바른 결과)
```

=> 모든 비트가 1(1111)이 되는 경우" 캐리 보정을 반드시 수행

### 결론

- 1의 보수에서는 덧셈 후, 결과가 캐리를 발생시키면 추가로 "1"을 다시 더해야 함
  ➡ 이 추가적인 덧셈을 수행하는 하드웨어가 필요
- 연산 속도 저하 유발
- 하드웨어가 복잡해짐

=> 2의 보수 방식이 1의 보수보다 선호되게 됨

# 3. 2의 보수에서 -8은 유일하게 자기 자신을 유지하는 경우이다

## why?

- 2의 보수(Two’s Complement)란?
  > 2의 보수는 음수를 표현하는 방법 중 하나로, 컴퓨터에서 가장 널리 사용되는 방식이다.
  >
  > 2의 보수는 "비트 반전(1의 보수) + 1을 더하는 방식"으로 음수를 표현

e.g.

```
// 양수(Positive Number)는 부호 없는 이진수와 동일

e.x +5 → 0101 (4비트 기준)

// 음수(Negative Number)는 다음 과정을 거쳐 표현

비트 반전(1의 보수 취하기)
0은 1로, 1은 0으로 변환
1을 더하기 (+1 연산)

e.x. +5를 2의 보수로 변환
+5의 이진수 (4비트 기준): 0101
1의 보수 취하기 (비트 반전): 1010
+1 더하기: 1011
```

- 2의 보수는 **N비트에서 표현 가능한 숫자의 범위가 정해져 있음**.
  `-2^(n-1) ~ 2^(n-1) - 1`
- **4비트에서는 표현 가능한 숫자 범위가 -8 ~ +7**  
  => 4비트 2의 보수에서는 "양수 8"을 나타낼 방법이 없다. 2의 보수법에서 MSB가 부호 비트이기 때문
  ![2의보수](https://i.namu.wiki/i/mK3vgX8q08DXax_Gx5nza8ZpT9ym9UKQP22wZbnID7XSzBU6MhWjNUtaZsgm8Cdscmew5Zz4MIX8zMVEbyQPwQ.webp)

## 2의 보수에서 -8이 자기 자신을 유지하는 이유

```
 //-8의 2의 보수 표현
8 -> 1000
반전 -> 0111
+1 -> 1000 (그대로!)

```

=> -8은 "2의 보수 변환을 수행해도 바뀌지 않는 고정점(Fixed Point)"이다.

## 여러 비트에서의 고정점

```
4비트 2의 보수 (고정점: -8): 0111
5비트 2의 보수 (고정점: -16): 01111
6비트의 2의 보수 (고정점: -32): 011111
```

고정점 규칙: N비트 2의 보수에서 항상 최소값 `−2^(n−1)`이 고정점이 된다.

## 수학적 원리

: 2의 보수를 취하는 과정은 "비트 반전 + 1"인데, 최소값은 항상 MSB가 1이고 나머지가 모두 0이라서, 반전 후 +1을 더해도 원래 값이 나온다.
가장 작은 음수는 "1 + 나머지 0" 형태이기 때문!

```
10000000   (-128)
반전 → 01111111
+1  → 10000000   (다시 -128이 됨!)
```

<!--

# 4. 부호와 크기 표현법과 기존 이진법은 혼용 가능한가?
-> 덧셈을 못하는 계산법
-->
# 1. 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고 올림은 두 비트를 AND 한 연산과 같다.

## 1) why?

1. 두 비트의 합

```
0+0=0 → 합비트 결과: 0
0+1=1 → 합비트 결과: 1
1+0=1 → 합비트 결과: 1
1+1=10 → 합비트 결과: 10
```

2. XOR 연산 (Exclusive OR, 배타적 논리합)

- XOR 연산이란?
  : 두 개의 입력이 다를 때 1을 출력하고, 같으면 0을 출력하는 연산

```
0 0=0 → XOR 결과: 0
0 1=1 → XOR 결과: 1
1 0=1 → XOR 결과: 1
1 1=10 (즉, 합 비트는 0이고 올림이 발생) → XOR 결과: 0
```

- XOR 연산은 이진수 덧셈에서 "합(Sum)"과 동일한 역할
  : XOR은 두 비트가 다를 때 1을 출력하고 같을 때 0을 출력한다. 이는 이진 덧셈에서 자릿수 합의 역할을 정확히 수행한다.

3. 올림 (Carry)과 AND 연산
   올림(Carry)은 두 개의 비트가 모두 1일 때 발생한다.

```
Carry=𝐴⋅𝐵=𝐴∧𝐵
```

// 올림 연산의 경우

```
0 0=0
0 1=0
1 0=0
1 1=1
```

// AND 연산의 경우

```
0 0=0
0 1=0
1 0=0
1 1=1
```

- 올림은 AND 연산과 동일

4. 수학적인 일반화

(1) XOR은 두 비트가 다를 때 1을 반환하는 성질이 있어서, 이진 덧셈의 합(Sum Bit) 역할을 한다.
(2) AND는 두 비트가 모두 1일 때만 1을 반환하는 성질이 있어서, 이진 덧셈의 올림(Carry Bit) 역할을 한다.

## 이진수 덧셈 진리표

| A   | B   | A + B (2진수) | 합 (Sum) | 올림 (Carry) |
| --- | --- | ------------- | -------- | ------------ |
| 0   | 0   | 0             | 0        | 0            |
| 0   | 1   | 1             | 1        | 0            |
| 1   | 0   | 1             | 1        | 0            |
| 1   | 1   | 10            | 0        | 1            |

이 규칙은 **반가산기(Half Adder)**의 기본적인 원리이기도 하다.

c.f. 반가산기?
: 이진수 덧셈을 수행하는 가장 기본적인 논리 회로로, 이진수의 한자리수를 연산하고 자리올림수는 자리올림수 출력(carry)에 따라 출력한다. AND, OR, NOT의 세 가지 종류의 논리회로만으로 구성할 수 있다. 하지만 이전 자리에서 발생한 올림(Carry-In)을 처리할 수 없다는 특징이 있어서 "반(Half)" 가산기라고 불린다.

![반가산기_회로](https://mblogthumb-phinf.pstatic.net/20110507_217/asd7979_1304732945444hrqAx_PNG/halfadder2.png?type=w420)

=> 이러한 성질을 기반으로, **반가산기(Half Adder)와 전가산기(Full Adder)**가 설계되고, 이것이 CPU에서 덧셈 연산을 수행하는 핵심 원리가 된다.

## 2) CPU에서 XOR을 수행하는 방식

: CPU는 기본 논리 게이트(AND, OR, NOT)를 조합해서 XOR을 구현

```
A⊕B=(A∨B)∧¬(A∧B)
```

- 하드웨어 최적화: XOR 게이트를 직접 사용하면 회로가 커질 수 있음 → 기본 게이트 조합이 더 효율적

  ** XOR은 기본 게이트보다 복잡한 논리 연산이라서, 하드웨어적으로 직접 만들면 추가적인 트랜지스터가 더 필요 **

  ** 든 논리 게이트는 **트랜지스터(Transistor)**로 구성됨. 트랜지스터 개수가 많아지면 회로가 커지고, 전력 소비가 증가하며, 속도도 저하 **

- 게이트 수 최소화: CPU는 AND, OR, NOT 게이트만으로 XOR을 구성하여 칩 크기를 줄이고 속도를 높임.
  (XOR을 직접 설계하면 추가적인 회로가 필요하므로 기존의 기본 게이트로 XOR을 구현하는 것이 경제적)

- 전가산기(Full Adder) 최적화: XOR이 포함된 전가산기 설계에서도 기본 논리 게이트로 XOR을 만들고 사용.

# 2. 왜 1의 보수 계산법에서는 추가적인 하드웨어가 들까?

## 1) 1의 보수(One’s Complement)란?

: 1의 보수는 음수를 표현하는 방법 중 하나로, **모든 비트를 반전(1 → 0, 0 → 1)**시켜 음수를 나타냄.

```
+5	0101
-5	1010 (반전)
+7	0111
-7	1000 (반전)
```

## 2) 1의 보수 덧셈에서 발생하는 캐리 보정 문제

: 1의 보수 방식에서는 캐리 비트가 발생하면 이를 다시 더해야 하는 "캐리 보정(Carry Correction)" 과정이 필요

c.f. 캐리 보정이란?
: 1의 보수(One's Complement) 연산에서 덧셈 결과가 올바르지 않을 때, 발생한 캐리를 다시 더해서 올바른 결과를 만드는 과정

e.g. (-5 + 3)

```
  1010   (-5, 1의 보수)
+ 0011   (+3)
------------
  1101   (-2의 1의 보수 표현)

```

e.g.3 (-3) + (-2)

```
  1100   (-3, 1의 보수)
+ 1101   (-2, 1의 보수)
------------
  10001   (5비트가 됨 → 최상위 캐리 발생)
+ 0001   (캐리 보정 추가)
------------
  0010   (-5, 1의 보수 표현)
```

=> 최상위 비트(MSB)에서 캐리가 발생한 경우, 발생한 캐리를 다시 결과에 더해야 한다.

e.g.2 (-5 + 5)

```
  1010   (-5, 1의 보수)
+ 0101   (+5)
------------
  1111   (올바른 결과는 0이어야 하나 결과가 -0)
+ 0001   (캐리 보정 추가)
------------
  0000   (최종적으로 올바른 결과)
```

=> 모든 비트가 1(1111)이 되는 경우" 캐리 보정을 반드시 수행

### 결론

- 1의 보수에서는 덧셈 후, 결과가 캐리를 발생시키면 추가로 "1"을 다시 더해야 함
  ➡ 이 추가적인 덧셈을 수행하는 하드웨어가 필요
- 연산 속도 저하 유발
- 하드웨어가 복잡해짐

=> 2의 보수 방식이 1의 보수보다 선호되게 됨

# 3. 2의 보수에서 -8은 유일하게 자기 자신을 유지하는 경우이다

## why?

- 2의 보수(Two’s Complement)란?
  > 2의 보수는 음수를 표현하는 방법 중 하나로, 컴퓨터에서 가장 널리 사용되는 방식이다.
  >
  > 2의 보수는 "비트 반전(1의 보수) + 1을 더하는 방식"으로 음수를 표현

e.g.

```
// 양수(Positive Number)는 부호 없는 이진수와 동일

e.x +5 → 0101 (4비트 기준)

// 음수(Negative Number)는 다음 과정을 거쳐 표현

비트 반전(1의 보수 취하기)
0은 1로, 1은 0으로 변환
1을 더하기 (+1 연산)

e.x. +5를 2의 보수로 변환
+5의 이진수 (4비트 기준): 0101
1의 보수 취하기 (비트 반전): 1010
+1 더하기: 1011
```

- 2의 보수는 **N비트에서 표현 가능한 숫자의 범위가 정해져 있음**.
  `-2^(n-1) ~ 2^(n-1) - 1`
- **4비트에서는 표현 가능한 숫자 범위가 -8 ~ +7**  
  => 4비트 2의 보수에서는 "양수 8"을 나타낼 방법이 없다. 2의 보수법에서 MSB가 부호 비트이기 때문
  ![2의보수](https://i.namu.wiki/i/mK3vgX8q08DXax_Gx5nza8ZpT9ym9UKQP22wZbnID7XSzBU6MhWjNUtaZsgm8Cdscmew5Zz4MIX8zMVEbyQPwQ.webp)

## 2의 보수에서 -8이 자기 자신을 유지하는 이유

```
 //-8의 2의 보수 표현
8 -> 1000
반전 -> 0111
+1 -> 1000 (그대로!)

```

=> -8은 "2의 보수 변환을 수행해도 바뀌지 않는 고정점(Fixed Point)"이다.

## 여러 비트에서의 고정점

```
4비트 2의 보수 (고정점: -8): 0111
5비트 2의 보수 (고정점: -16): 01111
6비트의 2의 보수 (고정점: -32): 011111
```

고정점 규칙: N비트 2의 보수에서 항상 최소값 `−2^(n−1)`이 고정점이 된다.

## 수학적 원리

: 2의 보수를 취하는 과정은 "비트 반전 + 1"인데, 최소값은 항상 MSB가 1이고 나머지가 모두 0이라서, 반전 후 +1을 더해도 원래 값이 나온다.
가장 작은 음수는 "1 + 나머지 0" 형태이기 때문!

```
10000000   (-128)
반전 → 01111111
+1  → 10000000   (다시 -128이 됨!)
```

<!--

# 4. 부호와 크기 표현법과 기존 이진법은 혼용 가능한가?
-> 덧셈을 못하는 계산법
-->
